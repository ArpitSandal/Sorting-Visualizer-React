{"ast":null,"code":"let animation = [];\n\nfunction merge(left, right) {\n  let arr = [],\n      i = 0,\n      j = 0; // Break out of loop if any one of the array gets empty\n\n  while (i < left.length && j < right.length) {\n    // Pick the smaller among the smallest element of left and right sub arrays\n    if (left[i][0] < right[j][0]) {\n      animation.push([left[i][1], right[j][1]]);\n      arr.push(left[i]);\n      i++;\n    } else {\n      animation.push([right[i][1], left[i][1]]);\n      arr.push(right[j]);\n      j++;\n    }\n  }\n\n  let n = left.length,\n      m = right.length;\n\n  while (i < left.length) {\n    animation.push([left[i][1], left[n - 1][1]]);\n    arr.push(left[i]);\n    i++;\n  }\n\n  while (j < right.length) {\n    animation.push([right[j][1], right[m - 1][1]]);\n    arr.push(right[j]);\n    j++;\n  } // Concatenating the leftover elements\n  // (in case we didn't go through the entire left or right array)\n\n\n  return arr;\n}\n\nfunction Sort(arr) {\n  const half = arr.length / 2; // Base case or terminating case\n\n  if (arr.length < 2) {\n    return arr;\n  }\n\n  const left = arr.splice(0, half);\n  return merge(Sort(left), Sort(arr));\n}\n\n_c = Sort;\n\nfunction MergeSort(ar) {\n  // console.log(ar);\n  let v = [];\n\n  for (let i = 0; i < ar.length; i++) {\n    v.push([ar[i], i]);\n  } //   console.log(v);\n  //   console.log(ar);\n\n\n  v = Sort(v); //   console.log(v);\n\n  return animation;\n}\n\n_c2 = MergeSort;\nexport default MergeSort;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"Sort\");\n$RefreshReg$(_c2, \"MergeSort\");","map":{"version":3,"sources":["D:/projects/sorting-visualizer/src/Sorting-algorithms/MergeSort.js"],"names":["animation","merge","left","right","arr","i","j","length","push","n","m","Sort","half","splice","MergeSort","ar","v"],"mappings":"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","sourcesContent":["let animation = [];\r\n\r\nfunction merge(left, right) {\r\n  let arr = [],\r\n    i = 0,\r\n    j = 0;\r\n  // Break out of loop if any one of the array gets empty\r\n  while (i < left.length && j < right.length) {\r\n    // Pick the smaller among the smallest element of left and right sub arrays\r\n    if (left[i][0] < right[j][0]) {\r\n        animation.push([left[i][1],right[j][1]]);\r\n      arr.push(left[i]);\r\n      i++;\r\n    } else {\r\n        animation.push([right[i][1],left[i][1]]);\r\n      arr.push(right[j]);\r\n      j++;\r\n    }\r\n  }\r\n  let n=left.length,m=right.length;\r\n  while (i < left.length) {\r\n    animation.push([left[i][1],left[n-1][1]]);\r\n    arr.push(left[i]);\r\n    i++;\r\n  }\r\n  while (j < right.length) {\r\n    animation.push([right[j][1],right[m-1][1]]);\r\n    arr.push(right[j]);\r\n    j++;\r\n  }\r\n\r\n  // Concatenating the leftover elements\r\n  // (in case we didn't go through the entire left or right array)\r\n  return arr;\r\n}\r\n\r\nfunction Sort(arr) {\r\n  const half = arr.length / 2;\r\n\r\n  // Base case or terminating case\r\n  if (arr.length < 2) {\r\n    return arr;\r\n  }\r\n\r\n  const left = arr.splice(0, half);\r\n  return merge(Sort(left), Sort(arr));\r\n}\r\n\r\nfunction MergeSort(ar) {\r\n    // console.log(ar);\r\n  let v = [];\r\n  for (let i = 0; i < ar.length; i++){\r\n   v.push([ar[i], i]);\r\n  }\r\n//   console.log(v);\r\n//   console.log(ar);\r\n  v=Sort(v);\r\n//   console.log(v);\r\n  return animation;\r\n}\r\n\r\nexport default MergeSort;\r\n"]},"metadata":{},"sourceType":"module"}