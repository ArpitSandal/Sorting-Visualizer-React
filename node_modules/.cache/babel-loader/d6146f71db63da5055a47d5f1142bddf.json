{"ast":null,"code":"let animation = [];\n\nfunction merge(left, right) {\n  let arr = [],\n      i = 0,\n      j = 0; // Break out of loop if any one of the array gets empty\n\n  while (i < left.length && j < right.length) {\n    // Pick the smaller among the smallest element of left and right sub arrays\n    if (left[i][0] < right[j][0]) {\n      animation.push([left[i][1], left[left.length - 1][1]]);\n      arr.push(left[i]);\n      i++;\n    } else {\n      animation.push([right[j][1], right[right.length - 1][1]]);\n      arr.push(right[j]);\n      j++;\n    }\n  }\n\n  while (i < left.length) {\n    animation.push([left[i][1], left[left.length - 1][1]]);\n    arr.push(left[i]);\n    i++;\n  }\n\n  while (j < right.length) {\n    animation.push([right[j][1], right[right.length - 1][1]]);\n    arr.push(right[j]);\n    j++;\n  } // Concatenating the leftover elements\n  // (in case we didn't go through the entire left or right array)\n\n\n  return arr;\n}\n\nfunction Sort(arr) {\n  const half = arr.length / 2; // Base case or terminating case\n\n  if (arr.length < 2) {\n    return arr;\n  }\n\n  const left = arr.splice(0, half);\n  return merge(Sort(left), Sort(arr));\n}\n\n_c = Sort;\n\nfunction MergeSort(ar) {\n  // console.log(ar);\n  let v = [];\n\n  for (let i = 0; i < ar.length; i++) {\n    v.push([ar[i], i]);\n  }\n\n  console.log(v); //   console.log(ar);\n\n  Sort(v); //   console.log(v);\n\n  return animation;\n}\n\n_c2 = MergeSort;\nexport default MergeSort;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"Sort\");\n$RefreshReg$(_c2, \"MergeSort\");","map":{"version":3,"sources":["D:/projects/sorting-visualizer/src/Sorting-algorithms/MergeSort.js"],"names":["animation","merge","left","right","arr","i","j","length","push","Sort","half","splice","MergeSort","ar","v","console","log"],"mappings":"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","sourcesContent":["let animation = [];\r\n\r\nfunction merge(left, right) {\r\n  let arr = [],\r\n    i = 0,\r\n    j = 0;\r\n  // Break out of loop if any one of the array gets empty\r\n  while (i < left.length && j < right.length) {\r\n    // Pick the smaller among the smallest element of left and right sub arrays\r\n    if (left[i][0] < right[j][0]) {\r\n        animation.push([left[i][1],left[left.length-1][1]]);\r\n      arr.push(left[i]);\r\n      i++;\r\n    } else {\r\n        animation.push([right[j][1],right[right.length-1][1]]);\r\n      arr.push(right[j]);\r\n      j++;\r\n    }\r\n  }\r\n  while (i < left.length) {\r\n    animation.push([left[i][1],left[left.length-1][1]]);\r\n    arr.push(left[i]);\r\n    i++;\r\n  }\r\n  while (j < right.length) {\r\n    animation.push([right[j][1],right[right.length-1][1]]);\r\n    arr.push(right[j]);\r\n    j++;\r\n  }\r\n\r\n  // Concatenating the leftover elements\r\n  // (in case we didn't go through the entire left or right array)\r\n  return arr;\r\n}\r\n\r\nfunction Sort(arr) {\r\n  const half = arr.length / 2;\r\n\r\n  // Base case or terminating case\r\n  if (arr.length < 2) {\r\n    return arr;\r\n  }\r\n\r\n  const left = arr.splice(0, half);\r\n  return merge(Sort(left), Sort(arr));\r\n}\r\n\r\nfunction MergeSort(ar) {\r\n    // console.log(ar);\r\n  let v = [];\r\n  for (let i = 0; i < ar.length; i++){\r\n   v.push([ar[i], i]);\r\n  }\r\n  console.log(v);\r\n//   console.log(ar);\r\n  Sort(v);\r\n//   console.log(v);\r\n  return animation;\r\n}\r\n\r\nexport default MergeSort;\r\n"]},"metadata":{},"sourceType":"module"}