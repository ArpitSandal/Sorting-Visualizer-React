{"ast":null,"code":"let animation = []; // Javascript program for the above approach\n// Calculating next gap\n\nfunction nextGap(gap) {\n  if (gap <= 1) return 0;\n  return Math.floor(Math.ceil(gap / 2.0));\n} // Function for swapping\n\n\nfunction swap(nums, i, j) {\n  animation.push([i, j]);\n  let temp = nums[i];\n  nums[i] = nums[j];\n  nums[j] = temp;\n} // Merging the subarrays using shell sorting\n// Time Complexity: O(nlog n)\n// Space Complexity: O(1)\n\n\nfunction inPlaceMerge(arr, start, end) {\n  let gap = end - start + 1;\n\n  for (gap = nextGap(gap); gap > 0; gap = nextGap(gap)) {\n    for (let i = start; i + gap <= end; i++) {\n      let j = i + gap;\n      if (arr[i] > arr[j]) swap(arr, i, j);\n    }\n  }\n} // merge sort makes log n recursive calls\n// and each time calls merge()\n// which takes nlog n steps\n// Time Complexity: O(n*log n + 2((n/2)*log(n/2)) +\n// 4((n/4)*log(n/4)) +.....+ 1)\n// Time Complexity: O(logn*(n*log n))\n// i.e. O(n*(logn)^2)\n// Space Complexity: O(1)\n\n\nfunction mergeSort(arr, s, e) {\n  if (s == e) return; // Calculating mid to slice the\n  // array in two halves\n\n  let mid = Math.floor((s + e) / 2); // Recursive calls to sort left\n  // and right subarrays\n\n  mergeSort(arr, s, mid);\n  mergeSort(arr, mid + 1, e);\n  inPlaceMerge(arr, s, e);\n}\n\nfunction MergeSort(arr) {\n  mergeSort(arr, 0, arr.length);\n  return animation;\n}\n\n_c = MergeSort;\nexport default MergeSort;\n\nvar _c;\n\n$RefreshReg$(_c, \"MergeSort\");","map":{"version":3,"sources":["D:/projects/sorting-visualizer/src/Sorting-algorithms/MergeSort.js"],"names":["animation","nextGap","gap","Math","floor","ceil","swap","nums","i","j","push","temp","inPlaceMerge","arr","start","end","mergeSort","s","e","mid","MergeSort","length"],"mappings":"AAAA,IAAIA,SAAS,GAAG,EAAhB,C,CAEA;AAEA;;AACA,SAASC,OAAT,CAAiBC,GAAjB,EACA;AACC,MAAIA,GAAG,IAAI,CAAX,EACE,OAAO,CAAP;AACD,SAAOC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,IAAL,CAAUH,GAAG,GAAG,GAAhB,CAAX,CAAP;AACD,C,CAED;;;AACA,SAASI,IAAT,CAAcC,IAAd,EAAmBC,CAAnB,EAAqBC,CAArB,EACA;AACIT,EAAAA,SAAS,CAACU,IAAV,CAAe,CAACF,CAAD,EAAGC,CAAH,CAAf;AACH,MAAIE,IAAI,GAAGJ,IAAI,CAACC,CAAD,CAAf;AACCD,EAAAA,IAAI,CAACC,CAAD,CAAJ,GAAUD,IAAI,CAACE,CAAD,CAAd;AACAF,EAAAA,IAAI,CAACE,CAAD,CAAJ,GAAUE,IAAV;AACD,C,CAED;AACC;AACA;;;AACD,SAASC,YAAT,CAAsBC,GAAtB,EAA0BC,KAA1B,EAAgCC,GAAhC,EACA;AACC,MAAIb,GAAG,GAAGa,GAAG,GAAGD,KAAN,GAAc,CAAxB;;AACC,OAAKZ,GAAG,GAAGD,OAAO,CAACC,GAAD,CAAlB,EAAyBA,GAAG,GAAG,CAA/B,EACCA,GAAG,GAAGD,OAAO,CAACC,GAAD,CADd,EACqB;AACpB,SAAK,IAAIM,CAAC,GAAGM,KAAb,EAAoBN,CAAC,GAAGN,GAAJ,IAAWa,GAA/B,EAAoCP,CAAC,EAArC,EAAyC;AACxC,UAAIC,CAAC,GAAGD,CAAC,GAAGN,GAAZ;AACA,UAAIW,GAAG,CAACL,CAAD,CAAH,GAASK,GAAG,CAACJ,CAAD,CAAhB,EACCH,IAAI,CAACO,GAAD,EAAML,CAAN,EAASC,CAAT,CAAJ;AACD;AACD;AACF,C,CAED;AACC;AACA;AACA;AACA;AACA;AACA;AACA;;;AACD,SAASO,SAAT,CAAmBH,GAAnB,EAAuBI,CAAvB,EAAyBC,CAAzB,EACA;AACC,MAAID,CAAC,IAAIC,CAAT,EACE,OAFH,CAIE;AACA;;AACA,MAAIC,GAAG,GAAGhB,IAAI,CAACC,KAAL,CAAW,CAACa,CAAC,GAAGC,CAAL,IAAU,CAArB,CAAV,CANF,CAQE;AACA;;AACAF,EAAAA,SAAS,CAACH,GAAD,EAAMI,CAAN,EAASE,GAAT,CAAT;AACAH,EAAAA,SAAS,CAACH,GAAD,EAAMM,GAAG,GAAG,CAAZ,EAAeD,CAAf,CAAT;AACAN,EAAAA,YAAY,CAACC,GAAD,EAAMI,CAAN,EAASC,CAAT,CAAZ;AACD;;AAGD,SAASE,SAAT,CAAmBP,GAAnB,EAAwB;AAEtBG,EAAAA,SAAS,CAACH,GAAD,EAAM,CAAN,EAASA,GAAG,CAACQ,MAAb,CAAT;AACA,SAAOrB,SAAP;AACD;;KAJQoB,S;AAMT,eAAeA,SAAf","sourcesContent":["let animation = [];\r\n\r\n// Javascript program for the above approach\r\n\r\n// Calculating next gap\r\nfunction nextGap(gap)\r\n{\r\n\tif (gap <= 1)\r\n\t\t\treturn 0;\r\n\t\treturn Math.floor(Math.ceil(gap / 2.0));\r\n}\r\n\r\n// Function for swapping\r\nfunction swap(nums,i,j)\r\n{\r\n    animation.push([i,j]);\r\n\tlet temp = nums[i];\r\n\t\tnums[i] = nums[j];\r\n\t\tnums[j] = temp;\r\n}\r\n\r\n// Merging the subarrays using shell sorting\r\n\t// Time Complexity: O(nlog n)\r\n\t// Space Complexity: O(1)\r\nfunction inPlaceMerge(arr,start,end)\r\n{\r\n\tlet gap = end - start + 1;\r\n\t\tfor (gap = nextGap(gap); gap > 0;\r\n\t\t\tgap = nextGap(gap)) {\r\n\t\t\tfor (let i = start; i + gap <= end; i++) {\r\n\t\t\t\tlet j = i + gap;\r\n\t\t\t\tif (arr[i] > arr[j])\r\n\t\t\t\t\tswap(arr, i, j);\r\n\t\t\t}\r\n\t\t}\r\n}\r\n\r\n// merge sort makes log n recursive calls\r\n\t// and each time calls merge()\r\n\t// which takes nlog n steps\r\n\t// Time Complexity: O(n*log n + 2((n/2)*log(n/2)) +\r\n\t// 4((n/4)*log(n/4)) +.....+ 1)\r\n\t// Time Complexity: O(logn*(n*log n))\r\n\t// i.e. O(n*(logn)^2)\r\n\t// Space Complexity: O(1)\r\nfunction mergeSort(arr,s,e)\r\n{\r\n\tif (s == e)\r\n\t\t\treturn;\r\n\r\n\t\t// Calculating mid to slice the\r\n\t\t// array in two halves\r\n\t\tlet mid = Math.floor((s + e) / 2);\r\n\r\n\t\t// Recursive calls to sort left\r\n\t\t// and right subarrays\r\n\t\tmergeSort(arr, s, mid);\r\n\t\tmergeSort(arr, mid + 1, e);\r\n\t\tinPlaceMerge(arr, s, e);\r\n}\r\n\r\n\r\nfunction MergeSort(arr) {\r\n\r\n  mergeSort(arr, 0, arr.length);\r\n  return animation;\r\n}\r\n\r\nexport default MergeSort;\r\n"]},"metadata":{},"sourceType":"module"}