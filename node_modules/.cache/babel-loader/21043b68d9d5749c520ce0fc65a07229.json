{"ast":null,"code":"let animation = []; // Javascript program for the above approach\n// Calculating next gap\n\nfunction nextGap(gap) {\n  if (gap <= 1) return 0;\n  return Math.floor(Math.ceil(gap / 2.0));\n} // Function for swapping\n\n\nfunction swap(nums, i, j) {\n  let temp = nums[i];\n  nums[i] = nums[j];\n  nums[j] = temp;\n} // Merging the subarrays using shell sorting\n// Time Complexity: O(nlog n)\n// Space Complexity: O(1)\n\n\nfunction inPlaceMerge(nums, start, end) {\n  let gap = end - start + 1;\n\n  for (gap = nextGap(gap); gap > 0; gap = nextGap(gap)) {\n    for (let i = start; i + gap <= end; i++) {\n      let j = i + gap;\n      if (nums[i] > nums[j]) swap(nums, i, j);\n    }\n  }\n} // merge sort makes log n recursive calls\n// and each time calls merge()\n// which takes nlog n steps\n// Time Complexity: O(n*log n + 2((n/2)*log(n/2)) +\n// 4((n/4)*log(n/4)) +.....+ 1)\n// Time Complexity: O(logn*(n*log n))\n// i.e. O(n*(logn)^2)\n// Space Complexity: O(1)\n\n\nfunction mergeSort(nums, s, e) {\n  if (s == e) return; // Calculating mid to slice the\n  // array in two halves\n\n  let mid = Math.floor((s + e) / 2); // Recursive calls to sort left\n  // and right subarrays\n\n  mergeSort(nums, s, mid);\n  mergeSort(nums, mid + 1, e);\n  inPlaceMerge(nums, s, e);\n}\n\nfunction MergeSort(arr) {\n  //   console.log(v);\n  //   console.log(ar);\n  mergeSort(arr);\n  console.log(arr);\n  return animation;\n}\n\n_c = MergeSort;\nexport default MergeSort;\n\nvar _c;\n\n$RefreshReg$(_c, \"MergeSort\");","map":{"version":3,"sources":["D:/projects/sorting-visualizer/src/Sorting-algorithms/MergeSort.js"],"names":["animation","nextGap","gap","Math","floor","ceil","swap","nums","i","j","temp","inPlaceMerge","start","end","mergeSort","s","e","mid","MergeSort","arr","console","log"],"mappings":"AAAA,IAAIA,SAAS,GAAG,EAAhB,C,CAEA;AAEA;;AACA,SAASC,OAAT,CAAiBC,GAAjB,EACA;AACC,MAAIA,GAAG,IAAI,CAAX,EACE,OAAO,CAAP;AACD,SAAOC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,IAAL,CAAUH,GAAG,GAAG,GAAhB,CAAX,CAAP;AACD,C,CAED;;;AACA,SAASI,IAAT,CAAcC,IAAd,EAAmBC,CAAnB,EAAqBC,CAArB,EACA;AACC,MAAIC,IAAI,GAAGH,IAAI,CAACC,CAAD,CAAf;AACCD,EAAAA,IAAI,CAACC,CAAD,CAAJ,GAAUD,IAAI,CAACE,CAAD,CAAd;AACAF,EAAAA,IAAI,CAACE,CAAD,CAAJ,GAAUC,IAAV;AACD,C,CAED;AACC;AACA;;;AACD,SAASC,YAAT,CAAsBJ,IAAtB,EAA2BK,KAA3B,EAAiCC,GAAjC,EACA;AACC,MAAIX,GAAG,GAAGW,GAAG,GAAGD,KAAN,GAAc,CAAxB;;AACC,OAAKV,GAAG,GAAGD,OAAO,CAACC,GAAD,CAAlB,EAAyBA,GAAG,GAAG,CAA/B,EACCA,GAAG,GAAGD,OAAO,CAACC,GAAD,CADd,EACqB;AACpB,SAAK,IAAIM,CAAC,GAAGI,KAAb,EAAoBJ,CAAC,GAAGN,GAAJ,IAAWW,GAA/B,EAAoCL,CAAC,EAArC,EAAyC;AACxC,UAAIC,CAAC,GAAGD,CAAC,GAAGN,GAAZ;AACA,UAAIK,IAAI,CAACC,CAAD,CAAJ,GAAUD,IAAI,CAACE,CAAD,CAAlB,EACCH,IAAI,CAACC,IAAD,EAAOC,CAAP,EAAUC,CAAV,CAAJ;AACD;AACD;AACF,C,CAED;AACC;AACA;AACA;AACA;AACA;AACA;AACA;;;AACD,SAASK,SAAT,CAAmBP,IAAnB,EAAwBQ,CAAxB,EAA0BC,CAA1B,EACA;AACC,MAAID,CAAC,IAAIC,CAAT,EACE,OAFH,CAIE;AACA;;AACA,MAAIC,GAAG,GAAGd,IAAI,CAACC,KAAL,CAAW,CAACW,CAAC,GAAGC,CAAL,IAAU,CAArB,CAAV,CANF,CAQE;AACA;;AACAF,EAAAA,SAAS,CAACP,IAAD,EAAOQ,CAAP,EAAUE,GAAV,CAAT;AACAH,EAAAA,SAAS,CAACP,IAAD,EAAOU,GAAG,GAAG,CAAb,EAAgBD,CAAhB,CAAT;AACAL,EAAAA,YAAY,CAACJ,IAAD,EAAOQ,CAAP,EAAUC,CAAV,CAAZ;AACD;;AAGD,SAASE,SAAT,CAAmBC,GAAnB,EAAwB;AACxB;AACA;AACEL,EAAAA,SAAS,CAACK,GAAD,CAAT;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAYF,GAAZ;AACA,SAAOnB,SAAP;AACD;;KANQkB,S;AAQT,eAAeA,SAAf","sourcesContent":["let animation = [];\r\n\r\n// Javascript program for the above approach\r\n\r\n// Calculating next gap\r\nfunction nextGap(gap)\r\n{\r\n\tif (gap <= 1)\r\n\t\t\treturn 0;\r\n\t\treturn Math.floor(Math.ceil(gap / 2.0));\r\n}\r\n\r\n// Function for swapping\r\nfunction swap(nums,i,j)\r\n{\r\n\tlet temp = nums[i];\r\n\t\tnums[i] = nums[j];\r\n\t\tnums[j] = temp;\r\n}\r\n\r\n// Merging the subarrays using shell sorting\r\n\t// Time Complexity: O(nlog n)\r\n\t// Space Complexity: O(1)\r\nfunction inPlaceMerge(nums,start,end)\r\n{\r\n\tlet gap = end - start + 1;\r\n\t\tfor (gap = nextGap(gap); gap > 0;\r\n\t\t\tgap = nextGap(gap)) {\r\n\t\t\tfor (let i = start; i + gap <= end; i++) {\r\n\t\t\t\tlet j = i + gap;\r\n\t\t\t\tif (nums[i] > nums[j])\r\n\t\t\t\t\tswap(nums, i, j);\r\n\t\t\t}\r\n\t\t}\r\n}\r\n\r\n// merge sort makes log n recursive calls\r\n\t// and each time calls merge()\r\n\t// which takes nlog n steps\r\n\t// Time Complexity: O(n*log n + 2((n/2)*log(n/2)) +\r\n\t// 4((n/4)*log(n/4)) +.....+ 1)\r\n\t// Time Complexity: O(logn*(n*log n))\r\n\t// i.e. O(n*(logn)^2)\r\n\t// Space Complexity: O(1)\r\nfunction mergeSort(nums,s,e)\r\n{\r\n\tif (s == e)\r\n\t\t\treturn;\r\n\r\n\t\t// Calculating mid to slice the\r\n\t\t// array in two halves\r\n\t\tlet mid = Math.floor((s + e) / 2);\r\n\r\n\t\t// Recursive calls to sort left\r\n\t\t// and right subarrays\r\n\t\tmergeSort(nums, s, mid);\r\n\t\tmergeSort(nums, mid + 1, e);\r\n\t\tinPlaceMerge(nums, s, e);\r\n}\r\n\r\n\r\nfunction MergeSort(arr) {\r\n//   console.log(v);\r\n//   console.log(ar);\r\n  mergeSort(arr);\r\n  console.log(arr);\r\n  return animation;\r\n}\r\n\r\nexport default MergeSort;\r\n"]},"metadata":{},"sourceType":"module"}