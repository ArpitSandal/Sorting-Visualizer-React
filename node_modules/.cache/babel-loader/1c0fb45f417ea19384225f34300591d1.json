{"ast":null,"code":"// JavaScript program for implementation\n// of Heap Sort\nfunction sort(arr) {\n  var n = arr.length; // Build heap (rearrange array)\n\n  for (var i = Math.floor(n / 2) - 1; i >= 0; i--) heapify(arr, n, i); // One by one extract an element from heap\n\n\n  for (var i = n - 1; i > 0; i--) {\n    // Move current root to end\n    var temp = arr[0];\n    arr[0] = arr[i];\n    arr[i] = temp; // call max heapify on the reduced heap\n\n    heapify(arr, i, 0);\n  }\n} // To heapify a subtree rooted with node i which is\n// an index in arr[]. n is size of heap\n\n\nfunction heapify(arr, n, i) {\n  var largest = i; // Initialize largest as root\n\n  var l = 2 * i + 1; // left = 2*i + 1\n\n  var r = 2 * i + 2; // right = 2*i + 2\n  // If left child is larger than root\n\n  if (l < n && arr[l] > arr[largest]) largest = l; // If right child is larger than largest so far\n\n  if (r < n && arr[r] > arr[largest]) largest = r; // If largest is not root\n\n  if (largest != i) {\n    var swap = arr[i];\n    arr[i] = arr[largest];\n    arr[largest] = swap; // Recursively heapify the affected sub-tree\n\n    heapify(arr, n, largest);\n  }\n}","map":{"version":3,"sources":["D:/projects/sorting-visualizer/src/Sorting-algorithms/HeapSort.js"],"names":["sort","arr","n","length","i","Math","floor","heapify","temp","largest","l","r","swap"],"mappings":"AACA;AACA;AAEA,SAASA,IAAT,CAAeC,GAAf,EACC;AACC,MAAIC,CAAC,GAAGD,GAAG,CAACE,MAAZ,CADD,CAGC;;AACA,OAAK,IAAIC,CAAC,GAAGC,IAAI,CAACC,KAAL,CAAWJ,CAAC,GAAG,CAAf,IAAoB,CAAjC,EAAoCE,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EACCG,OAAO,CAACN,GAAD,EAAMC,CAAN,EAASE,CAAT,CAAP,CALF,CAOC;;;AACA,OAAK,IAAIA,CAAC,GAAGF,CAAC,GAAG,CAAjB,EAAoBE,CAAC,GAAG,CAAxB,EAA2BA,CAAC,EAA5B,EAAgC;AAC/B;AACA,QAAII,IAAI,GAAGP,GAAG,CAAC,CAAD,CAAd;AACAA,IAAAA,GAAG,CAAC,CAAD,CAAH,GAASA,GAAG,CAACG,CAAD,CAAZ;AACAH,IAAAA,GAAG,CAACG,CAAD,CAAH,GAASI,IAAT,CAJ+B,CAM/B;;AACAD,IAAAA,OAAO,CAACN,GAAD,EAAMG,CAAN,EAAS,CAAT,CAAP;AACA;AACD,C,CAED;AACA;;;AACA,SAASG,OAAT,CAAiBN,GAAjB,EAAsBC,CAAtB,EAAyBE,CAAzB,EACA;AACC,MAAIK,OAAO,GAAGL,CAAd,CADD,CACkB;;AACjB,MAAIM,CAAC,GAAG,IAAIN,CAAJ,GAAQ,CAAhB,CAFD,CAEoB;;AACnB,MAAIO,CAAC,GAAG,IAAIP,CAAJ,GAAQ,CAAhB,CAHD,CAGoB;AAEnB;;AACA,MAAIM,CAAC,GAAGR,CAAJ,IAASD,GAAG,CAACS,CAAD,CAAH,GAAST,GAAG,CAACQ,OAAD,CAAzB,EACCA,OAAO,GAAGC,CAAV,CAPF,CASC;;AACA,MAAIC,CAAC,GAAGT,CAAJ,IAASD,GAAG,CAACU,CAAD,CAAH,GAASV,GAAG,CAACQ,OAAD,CAAzB,EACCA,OAAO,GAAGE,CAAV,CAXF,CAaC;;AACA,MAAIF,OAAO,IAAIL,CAAf,EAAkB;AACjB,QAAIQ,IAAI,GAAGX,GAAG,CAACG,CAAD,CAAd;AACAH,IAAAA,GAAG,CAACG,CAAD,CAAH,GAASH,GAAG,CAACQ,OAAD,CAAZ;AACAR,IAAAA,GAAG,CAACQ,OAAD,CAAH,GAAeG,IAAf,CAHiB,CAKjB;;AACAL,IAAAA,OAAO,CAACN,GAAD,EAAMC,CAAN,EAASO,OAAT,CAAP;AACA;AACD","sourcesContent":["\r\n// JavaScript program for implementation\r\n// of Heap Sort\r\n\r\nfunction sort( arr)\r\n\t{\r\n\t\tvar n = arr.length;\r\n\r\n\t\t// Build heap (rearrange array)\r\n\t\tfor (var i = Math.floor(n / 2) - 1; i >= 0; i--)\r\n\t\t\theapify(arr, n, i);\r\n\r\n\t\t// One by one extract an element from heap\r\n\t\tfor (var i = n - 1; i > 0; i--) {\r\n\t\t\t// Move current root to end\r\n\t\t\tvar temp = arr[0];\r\n\t\t\tarr[0] = arr[i];\r\n\t\t\tarr[i] = temp;\r\n\r\n\t\t\t// call max heapify on the reduced heap\r\n\t\t\theapify(arr, i, 0);\r\n\t\t}\r\n\t}\r\n\r\n\t// To heapify a subtree rooted with node i which is\r\n\t// an index in arr[]. n is size of heap\r\n\tfunction heapify(arr, n, i)\r\n\t{\r\n\t\tvar largest = i; // Initialize largest as root\r\n\t\tvar l = 2 * i + 1; // left = 2*i + 1\r\n\t\tvar r = 2 * i + 2; // right = 2*i + 2\r\n\r\n\t\t// If left child is larger than root\r\n\t\tif (l < n && arr[l] > arr[largest])\r\n\t\t\tlargest = l;\r\n\r\n\t\t// If right child is larger than largest so far\r\n\t\tif (r < n && arr[r] > arr[largest])\r\n\t\t\tlargest = r;\r\n\r\n\t\t// If largest is not root\r\n\t\tif (largest != i) {\r\n\t\t\tvar swap = arr[i];\r\n\t\t\tarr[i] = arr[largest];\r\n\t\t\tarr[largest] = swap;\r\n\r\n\t\t\t// Recursively heapify the affected sub-tree\r\n\t\t\theapify(arr, n, largest);\r\n\t\t}\r\n\t}"]},"metadata":{},"sourceType":"module"}